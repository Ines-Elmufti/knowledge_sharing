{"config":{"lang":["en","fr"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Aligning Two Models and Computing RMSD","text":""},{"location":"#introduction","title":"Introduction","text":"<p>When working with molecular structures or any other three-dimensional models, it's often necessary to align them to compare their similarities or differences. One common metric used to quantify the structural similarity between two models is the RMSD (Root Mean Square Deviation).</p>"},{"location":"#aligning-models","title":"Aligning Models","text":"<p>Aligning two models involves finding the optimal rotation and translation that minimizes the differences between their corresponding atoms or points. This process ensures that similar parts of the models overlap as closely as possible.</p> <p>Various algorithms can be used to perform model alignment, such as the Kabsch algorithm or quaternion-based methods. These algorithms typically involve calculating the optimal rotation matrix and translation vector based on the coordinates of corresponding atoms.</p> <p></p> <p>the image above shows structural alignment of thioredoxins from humans and the fly Drosophila melanogaster. The proteins are shown as ribbons, with the human protein in red, and the fly protein in yellow.</p>"},{"location":"#rmsd-calculation","title":"RMSD Calculation","text":"<p>Once the models are aligned, the RMSD can be computed to quantify the average deviation between corresponding atoms or points.</p>"},{"location":"intro_page/intro/","title":"Aligning Two Models and Calculate Similarities","text":""},{"location":"intro_page/intro/#introduction","title":"Introduction","text":"<p>When working with molecular structures or any other three-dimensional models, it's often necessary to align them to compare their similarities or differences. One common metric used to quantify the structural similarity between two models is the RMSD (Root Mean Square Deviation).</p>"},{"location":"intro_page/intro/#aligning-models","title":"Aligning Models","text":"<p>Aligning two models involves finding the optimal rotation and translation that minimizes the differences between their corresponding atoms or points. This process ensures that similar parts of the models overlap as closely as possible.</p> <p>Various algorithms can be used to perform model alignment, such as the Kabsch algorithm or quaternion-based methods. These algorithms typically involve calculating the optimal rotation matrix and translation vector based on the coordinates of corresponding atoms.</p> <p></p> <p>the image above shows structural alignment of thioredoxins from humans and the fly Drosophila melanogaster. The proteins are shown as ribbons, with the human protein in red, and the fly protein in yellow.</p>"},{"location":"intro_page/intro/#rmsd-calculation","title":"RMSD Calculation","text":"<p>Once the models are aligned, the RMSD can be computed to quantify the average deviation between corresponding atoms or points. </p>"},{"location":"scripts/compute_rmsd/","title":"Compute rmsd","text":"<p>(Please note that this page exists only in english. check introduction page to test translation feature) </p>"},{"location":"scripts/compute_rmsd/#compute_rmsd.rmsd_value","title":"<code>rmsd_value(input_model1, input_model2, alignment_chain_ids)</code>","text":"<p>Align models and compute RMSD value .</p> <p>Parameters:</p> Name Type Description Default <code>input_model1</code> <code>model</code> <p>First Bioblocks structure model</p> required <code>input_model2</code> <code>int</code> <p>Second Bioblocks structure model.</p> required <code>alignment_chain_ids</code> <code>list</code> <p>shared chain used for alignment</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If any chain ids in the input models are no identical.</p> <p>Returns:</p> Type Description <code>Model</code> <p>A new model in which all chains are reindexed consistently.</p> Source code in <code>scripts/compute_rmsd.py</code> <pre><code>def rmsd_value(input_model1: Model, input_model2: Model, alignment_chain_ids:list) -&gt; Model:\n    \"\"\"Align models and compute RMSD value .\n\n    Args:\n        input_model1 (model): First Bioblocks structure model\n        input_model2 (int): Second Bioblocks structure model.\n        alignment_chain_ids: shared chain used for alignment\n\n    Raises:\n        ValueError: If any chain ids in the input models are no identical.\n\n    Returns:\n        A new model in which all chains are reindexed consistently.\n    \"\"\"\n\n    model_1 = read_model(input_model1, suppress_warnings=True)\n    model_2 = read_model(input_model2, suppress_warnings=True)\n    if all(chain_id in model_1.get_chains() for chain_id in alignment_chain_ids) and all(chain_id in model_2.get_chains() for chain_id in alignment_chain_ids):\n        aligned_model_1 = usalign_models(\n            moving_model=model_1,\n            static_model=model_2,\n            alignment_chain_ids=[alignment_chain_ids]\n)\n    else:\n        raise ValueError(\n            \"chains don't match\"\n        )\n    rmsd_value = rmsd.compute_rmsd_between_models(aligned_model_1, model_2, chain_ids=[alignment_chain_ids])\n\n    return rmsd_value\n</code></pre>"},{"location":"scripts/compute_similarity_score/","title":"Compute similarity score","text":""},{"location":"scripts/compute_similarity_score/#compute_similarity_score.similarity_score","title":"<code>similarity_score(input_model1, input_model2)</code>","text":"<p>Align models and compute RMSD value .</p> <p>Parameters:</p> Name Type Description Default <code>input_model1</code> <code>model</code> <p>First Bioblocks structure model</p> required <code>input_model2</code> <code>int</code> <p>Second Bioblocks structure model.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple contains 2 similarity scores computed (identity_score,similarity_score)</p> Source code in <code>scripts/compute_similarity_score.py</code> <pre><code>def similarity_score(input_model1: Model, input_model2: Model) -&gt; tuple:\n    \"\"\"Align models and compute RMSD value .\n\n    Args:\n        input_model1 (model): First Bioblocks structure model\n        input_model2 (int): Second Bioblocks structure model.\n\n\n    Returns:\n        A tuple contains 2 similarity scores computed (identity_score,similarity_score)\n    \"\"\"\n\n    model_1 = read_model(input_model1, suppress_warnings=True)\n    model_2 = read_model(input_model2, suppress_warnings=True)\n    alignments = pairwise2.align.globalms(model_1, model_2, 2, -1, -0.5, -1)\n    alignment_score = 0\n    # calculates the percentage of identical residues between the aligned sequences.\n    for align in alignments:\n        alignment_score += align[0].count(\"-\")  # Count gaps in sequence 1\n        alignment_score += align[1].count(\"-\")  # Count gaps in sequence 2\n        alignment_score = len(model_1) - alignment_score  # Subtract gaps from total length\n\n    identity_score = (alignment_score / len(model_1)) * 100\n    similarity_score = alignments[0][2]\n    return (identity_score,similarity_score)\n</code></pre>"},{"location":"scripts/filter_structure/","title":"Filter structure","text":""},{"location":"scripts/filter_structure/#filter_structure.filter_model_structure","title":"<code>filter_model_structure(input_model, len_chain, atom_element)</code>","text":"<p>Filter your model from solvent molecules and non-canonical amino acids  .</p> <p>Parameters:</p> Name Type Description Default <code>input_model</code> <code>model</code> <p>Bioblocks structure model to be filtered</p> required <code>len_chain</code> <code>int</code> <p>Eliminate all Chain objects whose length is greater than len_chain.</p> required <code>atom_element</code> <code>str</code> <p>atom you wan to filter</p> required <p>Returns:</p> Type Description <code>Model</code> <p>A new filtered model ready for alignment.</p> Source code in <code>scripts/filter_structure.py</code> <pre><code>def filter_model_structure(input_model: Model, len_chain: int, atom_element:str) -&gt; Model:\n    \"\"\"Filter your model from solvent molecules and non-canonical amino acids  .\n\n    Args:\n        input_model (model): Bioblocks structure model to be filtered\n        len_chain: Eliminate all Chain objects whose length is greater than len_chain.\n        atom_element:atom you wan to filter\n\n\n    Returns:\n        A new filtered model ready for alignment.\n    \"\"\"\n\n    model = read_model(input_model, suppress_warnings=True)\n    non_canonical_1 = sum(not is_canonical_amino_acid(residue) for residue in model.get_residues())\n    print(f\"{repr(model)} contains {non_canonical_1} non-canonical residues\")\n    cleaned_model_1 = filter_residues(model, residue_filter=is_canonical_amino_acid)\n    non_canonical_1 = sum(not is_canonical_amino_acid(residue) for residue in cleaned_model_1.get_residues())\n    print(f\"{repr(cleaned_model_1)} contains {non_canonical_1} non-canonical residues\")\n    model_fc = filter_chains(non_canonical_1, chain_filter=lambda chain: len(chain) &lt; len_chain)\n    model_fa = filter_atoms(model_fc, atom_filter=lambda atom: atom.element == atom_element)\n\n\n    return model_fa\n</code></pre>"},{"location":"scripts/reindex_homomer_chains/","title":"Reindex homomer chains","text":""},{"location":"scripts/reindex_homomer_chains/#reindex_homomer_chains.reindex_homomer_model_chains","title":"<code>reindex_homomer_model_chains(input_model, starting_index)</code>","text":"<p>Renumber all the chains in a homomer structure with the same starting index.</p> <p>Parameters:</p> Name Type Description Default <code>input_model</code> <code>model</code> <p>Bioblocks structure model to renumber</p> required <code>starting_index</code> <code>int</code> <p>New index to start residue numbering from.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If any chain sequence in the input model is not identical.</p> <p>Returns:</p> Type Description <code>Model</code> <p>A new model in which all chains are reindexed consistently.</p> Source code in <code>scripts/reindex_homomer_chains.py</code> <pre><code>def reindex_homomer_model_chains(input_model: Model, starting_index: int) -&gt; Model:\n    \"\"\"Renumber all the chains in a homomer structure with the same starting index.\n\n    Args:\n        input_model (model): Bioblocks structure model to renumber\n        starting_index (int): New index to start residue numbering from.\n\n    Raises:\n        ValueError: If any chain sequence in the input model is not identical.\n\n    Returns:\n        A new model in which all chains are reindexed consistently.\n    \"\"\"\n    # Check that we have been given a homomer: All chain sequences must be identical,\n    # otherwise an error must be raised.\n    list_chain_ids_sequences = [\n        (chain.id, chain.sequence) for chain in input_model.get_chains()\n    ]\n    first_sequence = list_chain_ids_sequences[0][1]\n    if all(sequence == first_sequence for _, sequence in list_chain_ids_sequences):\n        list_chain_ids = [chain_id for chain_id, _ in list_chain_ids_sequences]\n    else:\n        raise ValueError(\n            \"Not all chains have the same sequence. Only homomers are accepted\"\n        )\n    # Assign the same starting index to all chains in the model.\n    dict_chain_starting_index = {chain: starting_index for chain in list_chain_ids}\n    logger.info(f\"Reindexing chains {list_chain_ids} starting from {starting_index}\")\n    reindexed_model = reindex_chains(\n        model=input_model, starting_residue_indices=dict_chain_starting_index\n    )\n    return reindexed_model\n</code></pre>"},{"location":"fr/","title":"Alignement de Deux Mod\u00e8les et Calcul du RMSD","text":""},{"location":"fr/#introduction","title":"Introduction","text":"<p>Lorsque l'on travaille avec des structures mol\u00e9culaires ou tout autre mod\u00e8le tridimensionnel, il est souvent n\u00e9cessaire de les aligner pour comparer leurs similitudes ou diff\u00e9rences. Une m\u00e9trique courante utilis\u00e9e pour quantifier la similarit\u00e9 structurale entre deux mod\u00e8les est le RMSD (Root Mean Square Deviation, ou \u00c9cart quadratique moyen).</p>"},{"location":"fr/#alignement-des-modeles","title":"Alignement des Mod\u00e8les","text":"<p>L'alignement de deux mod\u00e8les consiste \u00e0 trouver la rotation et la translation optimales qui minimisent les diff\u00e9rences entre leurs atomes ou points correspondants. Ce processus garantit que les parties similaires des mod\u00e8les se chevauchent le plus \u00e9troitement possible.</p> <p>Divers algorithmes peuvent \u00eatre utilis\u00e9s pour effectuer l'alignement des mod\u00e8les, tels que l'algorithme de Kabsch ou les m\u00e9thodes bas\u00e9es sur les quaternions. Ces algorithmes impliquent g\u00e9n\u00e9ralement le calcul de la matrice de rotation optimale et du vecteur de translation en fonction des coordonn\u00e9es des atomes correspondants.</p> <p></p> <p>L'image ci-dessus montre l'alignement structural des thioredoxines humaines et de la drosophile Drosophila melanogaster. Les prot\u00e9ines sont repr\u00e9sent\u00e9es sous forme de rubans, avec la prot\u00e9ine humaine en rouge et la prot\u00e9ine de la drosophile en jaune.</p>"},{"location":"fr/#calcul-du-rmsd","title":"Calcul du RMSD","text":"<p>Une fois que les mod\u00e8les sont align\u00e9s, le RMSD peut \u00eatre calcul\u00e9 pour quantifier l'\u00e9cart moyen entre les atomes ou points correspondants. </p>"},{"location":"fr/intro_page/intro/","title":"Alignement de Deux Mod\u00e8les et Calcul des Similarit\u00e9s","text":""},{"location":"fr/intro_page/intro/#introduction","title":"Introduction","text":"<p>Lorsque l'on travaille avec des structures mol\u00e9culaires ou tout autre mod\u00e8le tridimensionnel, il est souvent n\u00e9cessaire de les aligner pour comparer leurs similitudes ou diff\u00e9rences. Une m\u00e9trique courante utilis\u00e9e pour quantifier la similarit\u00e9 structurale entre deux mod\u00e8les est le RMSD (Root Mean Square Deviation, ou \u00c9cart quadratique moyen).</p>"},{"location":"fr/intro_page/intro/#alignement-des-modeles","title":"Alignement des Mod\u00e8les","text":"<p>L'alignement de deux mod\u00e8les consiste \u00e0 trouver la rotation et la translation optimales qui minimisent les diff\u00e9rences entre leurs atomes ou points correspondants. Ce processus garantit que les parties similaires des mod\u00e8les se chevauchent le plus \u00e9troitement possible.</p> <p>Divers algorithmes peuvent \u00eatre utilis\u00e9s pour effectuer l'alignement des mod\u00e8les, tels que l'algorithme de Kabsch ou les m\u00e9thodes bas\u00e9es sur les quaternions. Ces algorithmes impliquent g\u00e9n\u00e9ralement le calcul de la matrice de rotation optimale et du vecteur de translation en fonction des coordonn\u00e9es des atomes correspondants.</p> <p></p> <p>L'image ci-dessus montre l'alignement structural des thioredoxines humaines et de la drosophile Drosophila melanogaster. Les prot\u00e9ines sont repr\u00e9sent\u00e9es sous forme de rubans, avec la prot\u00e9ine humaine en rouge et la prot\u00e9ine de la drosophile en jaune.</p>"},{"location":"fr/intro_page/intro/#calcul-du-rmsd","title":"Calcul du RMSD","text":"<p>Une fois que les mod\u00e8les sont align\u00e9s, le RMSD peut \u00eatre calcul\u00e9 pour quantifier l'\u00e9cart moyen entre les atomes ou points correspondants. </p>"}]}